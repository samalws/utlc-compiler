id = x -> x;
$  = x -> x;
const = x -> y -> x;
ignore = x -> y -> y;
comp = f -> g -> x -> f `$ g x;
. = comp;
.2 = f -> g -> x -> y -> f `id g x y;

[BOOLEANS]
true  = const;
false = ignore;
!     = a -> a false true;
&     = a -> b -> a b false;
|     = a -> b -> a true b;
!&    = ! `.2 &;
!|    = ! `.2 |;
xor   = a -> b -> (a `| b) `& (a `!& b);
xnor  = ! `.2 xor;

[TUPLES]
,   = x -> y -> f -> f x y;
fst = t -> t const;
snd = t -> t ignore;
mapFst = f -> t -> f (fst t) `, snd t;
mapSnd = f -> t -> fst t `, f (snd t);

[CHURCH ENCODED NATURAL NUMBERS]
0  = f -> x -> x;
1  = ++ 0;
++ = n -> f -> x -> f `n f x;
-- = n -> fst `$ (t -> snd t `, ++ (snd t)) `n (0 `, 0);
+  = n -> m -> ++  `n m;
-  = n -> m -> --  `m n;
*  = n -> m -> + m `n 0;
/% = n -> m -> (0? (n `- m)) (0 `, n) (mapFst ++ `$ (n `- m) `/% m);
/  = n -> m -> fst `$ n `/% m;
%  = n -> m -> snd `$ n `/% m;
^  = n -> m -> * m `n 1;
0? = n -> const false `n true;
factorial = n -> (0? n) 1 (n `* factorial `$ -- n);
2 = ++ 1;
3 = ++ 2;
4 = ++ 3;
5 = ++ 4;
6 = ++ 5;
7 = ++ 6;
8 = ++ 7;
9 = ++ 8;
10 = ++ 9;

[MAYBE]
none  = f -> x -> x;
some  = a -> f -> x -> f a;
none? = m -> m (const false) true;
some? = m -> m (const true) false;

[SCOTT ENCODED LISTS]
null   = f -> x -> x;
:      = h -> t -> f -> x -> f h t;
null?  = l -> l (const `$ const false) true;
car    = l -> l (some `.2 const) none;
cdr    = l -> l ignore none;
@      = l -> n -> 0? n (car l) (cdr l `@ -- n);
single = h -> h `: null;

[FAST NATS - LIST OF BOOLEANS - O(log n)]
[precondition for a lot of this: there is a true at the end of the list]
F0   = null;
F++  = n -> n (h -> r -> h (false `: F++ r) (true `: r)) (single true);                                [O(log n)]
F0?  = null?;
F->n = n -> n (h -> r -> (h 1 0) `+ (2 `* F->n r)) 0;  [convert to church encoded zero/succ ints]
F--  = n -> n (h -> r -> h (null? r null (false `: r)) (true `: F-- r)) null;                          [O(log n)]
F+   = n -> m -> n (hn -> tn -> m (hm -> tm -> (hn `xor hm) `: ((hn `& hm) F++ id `$ tn `F+ tm)) n) m; [O(log (max m n))]
F*   = n -> m -> n (hn -> tn -> hn m F0   `F+   tn  `F*  false `: m) F0;                               [O(log n * log m)]
Ffactorial = n -> F0? n F1 `$  n `F* Ffactorial `$ F-- n;

[convert to native int; we assume the compiler provides us with zero, succ, plus, and times functions on native ints]
F->bn = n -> zero -> succ -> plus -> times -> n (h -> t -> h (succ zero) zero `plus succ (succ zero) `times F->bn t zero succ plus times) zero;

F1 = F++ F0;
F2 = F++ F1;
F3 = F++ F2;
F4 = F++ F3;
F5 = F++ F4;
F6 = F++ F5;
F7 = F++ F6;
F8 = F++ F7;
F9 = F++ F8;
F10 = F++ F9;

[20 factorial in .02 seconds!]
myNum  = Ffactorial `$ F2 `F* F10;

main = F->bn myNum;
