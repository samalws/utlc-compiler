id = x -> x;
$  = x -> x;
const = x -> y -> x;
ignore = x -> y -> y;
comp = f -> g -> x -> f `$ g x;
. = comp;
.2 = f -> g -> x -> y -> f `id g x y;

[BOOLEANS]
true  = const;
false = ignore;
!     = a -> a false true;
&     = a -> b -> a b false;
|     = a -> b -> a true b;
!&    = ! `.2 &;
!|    = ! `.2 |;
xor   = a -> b -> (a `| b) `& (a `!& b);
xnor  = ! `.2 xor;
=b   = xnor;
!=b  = xor;

[TUPLES]
,   = x -> y -> f -> f x y;
fst = t -> t const;
snd = t -> t ignore;
mapFst = f -> t -> f (fst t) `, snd t;
mapSnd = f -> t -> fst t `, f (snd t);
=,     = =a -> =b -> t1 -> t2 -> (fst t1 `=a fst t2) `& (snd t1 `=b snd t2);
!=,    = =a -> =b -> ! `.2 =, =a =b;

[CHURCH ENCODED NATURAL NUMBERS]
0N  = f -> x -> x;
1N  = ++N 0;
++N = n -> f -> x -> f `n f x;
--N = n -> fst `$ (t -> snd t `, ++ (snd t)) `n (0N `, 0N);
+N  = n -> m -> ++N `n m;
-N  = n -> m -> --N `m n;
*N  = n -> m -> +N m `n 0N;
/%N = n -> m -> (0?N (n `- m)) (0 `, n) (mapFst ++ `$ (n `- m) `/%N m);
/N  = n -> m -> fst `$ n `/%N m;
%N  = n -> m -> snd `$ n `/%N m;
^N  = n -> m -> *N m `n 1N;
0?N = n -> const false `n true;
factorialN = n -> (0?N n) 1N (n `*N factorialN `$ --N n);
2N = ++N 1N;
3N = ++N 2N;
4N = ++N 3N;
5N = ++N 4N;
6N = ++N 5N;
7N = ++N 6N;
8N = ++N 7N;
9N = ++N 8N;
10N = ++N 9N;
=N  = a -> b -> (0?N `$ a `-N b) `& (0?N `$ b `-N a);
!=N = ! `.2 =N;
[TODO n>, n<, ...]

[MAYBE]
none  = f -> x -> x;
some  = a -> f -> x -> f a;
none? = m -> m (const false) true;
some? = m -> m (const true) false;
=m    = =a -> m1 -> m2 -> m1 (a1 -> m2 (a2 -> a1 `=a a2) false) (none? m2);
!=m   = =a -> ! `.2 =m =a;

[SCOTT ENCODED LISTS]
null   = f -> x -> x;
:      = h -> t -> f -> x -> f h t;
null?  = l -> l (const `$ const false) true;
car    = l -> l (some `.2 const) none;
cdr    = l -> l ignore none;
@      = l -> n -> 0? n (car l) (cdr l `@ -- n);
single = h -> h `: null;
=l     = =a -> l1 -> l2 -> l1 (h1 -> t1 -> l2 (h2 -> t2 -> (h1 `=a h2) `& (=l =a t1 t2)) false) (null? l2);
!=l    = =a -> ! `.2 =l =a;
+l     = l1 -> l2 -> l1 (h -> t -> h `: t `+l l2) l2; [concat lists; O(n)]
rev    = l -> l (h -> r -> rev r `+l single h) null;  [reverse list; O(n^2)?] [TODO make this into O(n); this is doable if you have an accumulator]
len    = l -> l (h -> r -> ++ `$ len r) 0;
map    = f -> l -> l (h -> r -> f h `: map f r) null;
foldr  = f -> x -> l -> l (h -> t -> f h (foldr f x t)) x;
last   = foldr (h -> e -> e id (some h)) none;
[TODO >, <]
l->bl  = l -> convElem -> empty -> cons -> l (h -> t -> convElem h `cons l->bl t convElem empty cons) empty;

[BOOLEAN LIST NATURAL NUMBERS]
[order: LSD to MSD]
[precondition for a lot of this: there is a true at the end of the list]
0    = null;
++   = n -> n (h -> r -> h (false `: ++ r) (true `: r)) (single true);                                [O(log n)]
0?   = null?;
n->N = n -> n (h -> r -> (h 1N 0N) `+N (2N `*N n->N r)) 0N;  [convert to church encoded zero/succ ints]
N->n = n -> n ++ 0;
--   = n -> n (h -> r -> h (null? r null (false `: r)) (true `: -- r)) null;                         [O(log n)]
+    = n -> m -> n (hn -> tn -> m (hm -> tm -> (hn `xor hm) `: ((hn `& hm) ++ id `$ tn `+ tm)) n) m; [O(log (max m n))]
*    = n -> m -> n (hn -> tn -> hn m 0   `+   tn  `*  false `: m) 0;                                 [O(log n * log m)]
/%   = n -> m -> (n `<n m) (0 `, n) `$ ((n `- m) `/% m) (div -> mod -> ++ div `, mod);                [at least O(m/n), TODO do this better]
/    = n -> m -> fst `$ n `/% m;
%    = n -> m -> snd `$ n `/% m;
=n   = =l =b;
!=n  = ! `.2 =n;
<=n  = n -> m -> 0? `$ n `- m;
>=n  = n -> m -> m `<=n n;
<n   = ! `.2 >=n;
>n   = ! `.2 <=n;
factorial = n -> 0? n 1 `$  n `* factorial `$ -- n;
[convert fast nat to string]
_n->s = n -> 0? n null `$ (n `/% 10) (div -> mod -> _n->s div `+l ((c`0 `+ mod) `: null)); [TODO use rev instead of +l, because rev will be O(n)]
n->s  = n -> 0? n "0" (_n->s n);

[SUBTRACTION OF BOOLEAN LIST NATS]
00- = tn -> tm -> (tn `_- tm) (x -> some `$ 0? x 0 (false `: x)) none;
01- = tn -> tm -> -- (false `: tn) `_- -- (true `: tm);
10- = tn -> tm -> (tn `_- tm) (x -> some `$ true `: x) none;
11- = tn -> tm -> (tn `_- tm) (x -> some `$ 0? x 0 (false `: x)) none;
__- = hn -> tn -> hm -> tm -> (hn (hm 11- 10-) (hm 01- 00-)) tn tm;
_-  = n -> m -> m (hm -> tm -> n (hn -> tn -> __- hn tn hm tm) none) (some n);
-   = n -> m -> (n `_- m) id 0;

[convert to native int; we assume the compiler provides us with zero, succ, plus, and times functions on native ints]
n->bn = n -> zero -> succ -> plus -> times -> n (h -> t -> h (succ zero) zero `plus succ (succ zero) `times n->bn t zero succ plus times) zero;
bn->n = n -> n 0 ++ + *;

1 = ++ 0;
2 = ++ 1;
3 = ++ 2;
4 = ++ 3;
5 = ++ 4;
6 = ++ 5;
7 = ++ 6;
8 = ++ 7;
9 = ++ 8;
10 = ++ 9;

[BASE STRING CONVERSION]
s->bs = s -> zero -> succ -> plus -> times -> empty -> cons -> l->bl s (n -> n->bn n zero succ plus times) empty cons;
bs->s = s -> map bn->n `$ s null :;

[PARSERS]
pc  = s -> null? s none `$ !=n 1 (len s) none `$ car s;
_pn = s -> s (c -> r -> ((c `<n c`0) `| (c `>n c`9)) none `$ _pn r (n -> some `$ (c `- c`0) `+ n `* 10) none) (some 0);
pn  = s -> null? s none (_pn `$ rev s);

[VARIADIC FUNCTIONS]
fireList = f -> l -> l (h -> t -> fireList (f h) t) f;
nComp = n -> 0? n id (f -> g -> x -> nComp (-- n) f (g x));
nGather = n -> 0? n null (x -> nComp (-- n) (: x) (nGather (-- n)));
nVariadic = f -> n -> nComp n f (nGather n);
nRev = f -> nVariadic (l -> foldr id f (rev l));
nConst = nVariadic (l -> last l id id) `. ++;
nIgnore = nVariadic (l -> car l id id) `. ++;
