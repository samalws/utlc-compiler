fn de_pi<T>(a: Monotype<T>) -> BigInt {
  match a {
    Monotype::PI0(n) => n.clone(),
    _ => panic!("Expected int")
  }
}

fn try_de_pi_thunk(a: B<Thunk>) -> Option<BigInt> {
  match &*a.lock().unwrap() {
    Thunk::Ctor(n) => Some(de_pi(n.clone())),
    _ => None,
  }
}

fn de_pi_thunk(a: B<Thunk>) -> BigInt {
  match &*a.lock().unwrap() {
    Thunk::Ctor(n) => de_pi(n.clone()),
    _ => panic!("de_pi_thunk expected ctor"),
  }
}

fn pi_ctor<T>(a: u64) -> Monotype<T> {
  Monotype::PI0(BigInt::from(a))
}

fn conv_num(n: BigInt, z: B<Thunk>, s: B<Thunk>, a: B<Thunk>, m: B<Thunk>) -> B<Thunk> {
  if n == BigInt::from(0) {
    z
  } else if n == BigInt::from(1) {
    new_eval(s,z)
  } else if n == BigInt::from(2) {
    new_eval(s.clone(),new_eval(s,z))
  } else {
    let conv_again = |nn| conv_num(nn, z.clone(), s.clone(), a.clone(), m.clone());
    let two = || BigInt::from(2);
    let ones_digit = conv_again(n.clone() % two());
    let upper_digits = conv_again(n.clone() / two());
    let two_conv = conv_again(two());
    new_eval(new_eval(a.clone(),ones_digit),new_eval(new_eval(m.clone(),two_conv),upper_digits))
  }
}

fn de_pt<T>(a: Monotype<T>) -> (T, T) {
  match a {
    Monotype::PT0(a,b) => (a, b),
    _ => panic!("Expected tuple")
  }
}

fn de_pt_thunk(a: B<Thunk>) -> (B<Thunk>, B<Thunk>) {
  match &*a.lock().unwrap() {
    Thunk::Ctor(b) => de_pt(b.clone()),
    _ => panic!("de_pt_thunk expected ctor"),
  }
}

fn de_pl_thunk(a: B<Thunk>) -> Vec<BigInt> {
  let mut return_val = Vec::new();
  let mut scan_elem = a;
  loop {
    simplify(scan_elem.clone());
    match &*scan_elem.clone().lock().unwrap() {
      Thunk::Ctor(b) => match b {
        Monotype::PNull0 => break,
        Monotype::PCons2(n, r) => { return_val.push(n.clone()); scan_elem = r.clone(); },
        _ => panic!("expected list value"),
      },
      _ => panic!("de_pl_thunk expected ctor"),
    };
  };
  return_val
}

fn mono_to_str(a: B<Thunk>) -> String {
  let mut m = a;
  m = new_eval(m, new_ctor(pi_ctor(0)));
  m = new_eval(m, new_ctor(Monotype::PSucc0));
  m = new_eval(m, new_ctor(Monotype::PAdd0 ));
  m = new_eval(m, new_ctor(Monotype::PMul0 ));
  m = new_eval(m, new_ctor(Monotype::PNull0));
  m = new_eval(m, new_ctor(Monotype::PCons0));
  let as_list = de_pl_thunk(m);
  let mut utf8_list = Vec::new();
  for c in as_list {
    utf8_list.push(c.to_bytes_be().1[0]);
  }
  String::from_utf8(utf8_list).unwrap()
}

fn str_to_mono(s: String) -> B<Thunk> {
  let mut ret_val = new_ctor(Monotype::PNull0);
  let mut tmp_vec = Vec::new();
  for c in s.bytes() {
    tmp_vec.push(c);
  }
  tmp_vec.reverse();
  for c in tmp_vec {
    ret_val = new_ctor(Monotype::PCons2(BigInt::from(c), ret_val));
  }
  ret_val
}

fn main() {
  let mut a = new_ctor(MAIN_CTOR);
  loop {
    a = new_eval(a, new_ctor(Monotype::PComma0));
    simplify(a.clone());
    let t = de_pt_thunk(a.clone());
    let otp = mono_to_str(t.0);
    if otp == "q" {
      break;
    }
    println!("{}", otp.substring(1,otp.len()));
    let mut inp = String::new();
    std::io::stdin().read_line(&mut inp).unwrap();
    a = new_eval(t.1, str_to_mono(inp.substring(0,inp.len()-1).to_string()));
  }
}
